<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MGZJP4K');</script>
<!-- End Google Tag Manager -->

  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Anatolii Kmetiuk - Introduction to Recursion Schemes with Matryoshka</title>
<meta name="author" content="Anatolii Kmetiuk" />

<meta name="description" content="Motivation for the recursion schemes based on fixed-point types and their implementation in Matryoshka.">
<meta name="keywords" content="scala, programming, functional programming, category theory, recursion schemes, matryoshka, catamorphism, recursion">

<!-- Facebook tags -->
<meta property="og:title" content="Introduction to Recursion Schemes with Matryoshka">
<meta property="og:type" content="article">
<meta property="og:url" content="http://akmetiuk.com/posts/2017-03-10-matryoshka-intro.html">
<meta property="og:image" content="http://akmetiuk.com/assets/imgs/avatar_100.png">
<meta property="og:description" content="Motivation for the recursion schemes based on fixed-point types and their implementation in Matryoshka.">
<meta property="og:site_name" content="The blog of Anatolii Kmetiuk">
<meta property="og:locale" content="en-GB">

<!-- Twitter tags -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:description" content="Motivation for the recursion schemes based on fixed-point types and their implementation in Matryoshka." />
<meta name="twitter:title" content="Introduction to Recursion Schemes with Matryoshka" />
<meta name="twitter:site" content="@akmetiuk" />
<meta name="twitter:image" content="http://akmetiuk.com/assets/imgs/avatar_100.png" />
<meta name="twitter:creator" content="@akmetiuk" />


  <link rel="canonical" href="http://akmetiuk.com/posts/2017-03-10-matryoshka-intro.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/atom+xml" title="Anatolii Kmetiuk" href="http://akmetiuk.com/atom.xml" />

  <link rel="stylesheet" href="/assets/all.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha256-k2/8zcNbxVIh5mnQ52A0r3a6jAgMGxFJFE2707UxGCk= sha512-ZV9KawG2Legkwp3nAlxLIVFudTauWuBpC10uEafMHYL0Sarrz5A7G79kXh5+5+woxQ5HM559XX2UZjMJ36Wplg==" crossorigin="anonymous">
</head>
<body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MGZJP4K"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <h1>Hi.</h1>
  <a href="/">
    <img src="/assets/imgs/avatar_200.png" id="logo" alt="Blog logo"/>
  </a>
  <h2>I'm <a href="/">Anatolii Kmetiuk</a>.</h2>
  <div id="bio">
    <p>ðŸ’»I'm a compiler engineer at LAMP/EPFL, working on Scala 3.</p>
    <p>Check out the books I've written:</p>
    <p>ðŸ“•<a href="https://www.amazon.com/Mastering-Functional-Programming-techniques-programming/dp/1788620798/">Mastering Functional Programming</a> â€“ the motivation behind purely functional libraries such as Cats.</p>
    <p>ðŸ“•<a href="/assets/files/story-of-one-library.pdf">[Free] A Story of One Library</a> â€“ a commit-by-commit analysis of an application from the very start. The challenges that were arising during the implementation are addressed in a functional way, so that the reader can understand the motivation behind the functional techniques.</p>
  </div>
  <div id="social">
    Where to find me:
    <div id="stalker">
      <a title="anatoliykmetyuk on Github" href="https://github.com/anatoliykmetyuk">
        <i class="fa fa-github-square"></i>
      </a>

      <a title="akmetiuk on Twitter" href="https://twitter.com/akmetiuk">
        <i class="fa fa-twitter-square"></i>
      </a>

      <a title="Anatolii Kmetiuk on LinkedIn" href="https://www.linkedin.com/in/akmetiuk">
        <i class="fa fa-linkedin-square"></i>
      </a>
    </div>
  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  Mar 10, 2017
  <a href="/">
    <i class="home fa fa-home"></i>
  </a>
</p>

<h1 class="title">Introduction to Recursion Schemes with Matryoshka</h1>
<div id="post">
  <div class="toc">
<ul>
<li><a href="#recursive-data-structures">Recursive data structures</a><ul>
<li><a href="#natural-numbers">Natural Numbers</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#expressions">Expressions</a></li>
</ul></li>
<li><a href="#generalisation">Generalisation</a><ul>
<li><a href="#structure-preserving-transformations">Structure preserving transformations</a></li>
<li><a href="#new-definitions-for-the-recursive-structures">New definitions for the recursive structures</a></li>
<li><a href="#functors">Functors</a></li>
<li><a href="#catamorphism-first-attempt">Catamorphism: first attempt</a></li>
<li><a href="#fixed-point-types">Fixed-point types</a><ul>
<li><a href="#theory">Theory</a></li>
<li><a href="#practice">Practice</a></li>
</ul></li>
<li><a href="#catamorphism-second-attempt">Catamorphism: second attempt</a></li>
<li><a href="#examples-using-cata">Examples using <code>cata</code></a></li>
</ul></li>
<li><a href="#matryoshka">Matryoshka</a><ul>
<li><a href="#recursion-scheme-mechanics">Recursion scheme mechanics</a><ul>
<li><a href="#recursive---to-tear-structures-down">Recursive - to tear structures down</a></li>
<li><a href="#corecursive---to-build-structures-up">Corecursive - to build structures up</a></li>
</ul></li>
<li><a href="#examples-revisited">Examples revisited</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
<div class="body">
<blockquote>
<p>Recursion is the GOTO of functional programming - Erik Meijer<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
</blockquote>
<h1 id="recursive-data-structures">Recursive data structures</h1>
<p>In our daily programming life, we encounter recursive data structures on a regular basis. The best-known examples include linked lists and trees. Often working with such data structures we have a need to evaluate (collapse) them to a value. For example:</p>
<ul>
<li>Given a list of integers, say 1, 2 and 3, one may want to find their sum 6.</li>
<li>Given a parser of arithmetic expressions, such as <code>2 * 3 + 3</code>, we can expect it to produce a tree out of that expression - <code>Add(Mult(Num(2), Num(3)), Num(3))</code>. Such trees often need to be evaluated by actually performing these mathematical operations.</li>
<li>A more abstract example: natural numbers. Given the number zero and an ability to construct a successor of any natural number, you can construct all the natural numbers. If <code>Zero</code> is such a zero number, and <code>Succ(x)</code> constructs a natural number following <code>x</code>, <code>Succ(Succ(Succ(Zero)))</code> can represent <code>3</code>. This is also a recursive structure, and the simplest operation you want to do on it is to actually evaluate it to an <code>Int</code>: <code>Nat =&gt; Int</code>.</li>
</ul>
<p>In this article, we shall see how all of these examples involve recursion. <a href="https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself">Don't Repeat Yourself (DRY)</a> is one of the fundamental principles of programming - so, if we repeat recursion from example to example, we should abstract it away. We shall see how to do that.</p>
<p>But first, let us set the foundation by doing all of the above examples in code.</p>
<h2 id="natural-numbers">Natural Numbers</h2>
<p>Here is how an implementation of natural numbers might look like:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C1NonDry.scala" snippet="NatDef"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Nat</span>
<span class="kw">sealed</span> <span class="kw">trait</span> Nat
<span class="kw">case</span> <span class="kw">class</span>   <span class="fu">Succ</span>(previous: Nat) <span class="kw">extends</span> Nat
<span class="kw">case</span> <span class="kw">object</span>  Zero                <span class="kw">extends</span> Nat</code></pre></div>
<p>And here is a visualization of the number 3 represented this way:</p>
<p><img src="/graphviz-images/d9ff53e2f9ff69105d777acde205f42074e13c8c.png" id="nat_diagram" style="width:100.0%" /></p>
<p>This would correspond to <code>Succ(Succ(Succ(Zero)))</code>. Note the recursive nature of this structure: a smaller substructure of the same type is present in every structure (except the terminal one, <code>Zero</code>).</p>
<p>Now, let us see how to evaluate a natural number to an <code>Int</code>. In order to do this for an arbitrary <code>Succ(x)</code>, we need to evaluate <code>x</code> and add 1 to the result. <code>Zero</code> should evaluate to 0:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C1NonDry.scala" snippet="NatEx"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Nat to Int</span>
<span class="kw">def</span> <span class="fu">natToInt</span>(n: Nat): Int = n <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Succ</span>(x) =&gt; <span class="dv">1</span> + <span class="fu">natToInt</span>(x)
  <span class="kw">case</span> Zero    =&gt; <span class="dv">0</span>
}
<span class="kw">val</span> nat = <span class="fu">Succ</span>(<span class="fu">Succ</span>(<span class="fu">Succ</span>(Zero)))
<span class="kw">val</span> natRes: Int = <span class="fu">natToInt</span>(nat)
<span class="fu">println</span>(natRes)  <span class="co">// 3</span></code></pre></div>
<h2 id="lists">Lists</h2>
<p>Now let us see how to implement a list as a recursive structure:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C1NonDry.scala" snippet="ListDef"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// List</span>
<span class="kw">sealed</span> <span class="kw">trait</span> IntList
<span class="kw">case</span> <span class="kw">class</span>   <span class="fu">Cons</span>(head: Int, tail: IntList) <span class="kw">extends</span> IntList
<span class="kw">case</span> <span class="kw">object</span>  Empty                          <span class="kw">extends</span> IntList</code></pre></div>
<p>A list is either an empty list or a recursive structure that has a <code>head</code> element and a <code>tail</code> - a sublist representing all the elements following the <code>head</code>. For simplicity, we only consider lists of <code>Int</code>.</p>
<p>Here is how a list of <code>1, 2, 3</code> looks like:</p>
<p><img src="/graphviz-images/740874b29610e546049d6bef221cdabfd0e7891d.png" id="list_diagram" /></p>
<p>In order to find the sum of all the elements in a list, we should add its <code>head</code> to the sum of all the elements of its <code>tail</code>. If the list is <code>Empty</code>, the result of the summation is 0:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C1NonDry.scala" snippet="ListEx"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Sum a list of ints</span>
<span class="kw">def</span> <span class="fu">sumList</span>(l: IntList): Int = l <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Cons</span>(head, tail) =&gt; head + <span class="fu">sumList</span>(tail)
  <span class="kw">case</span> Empty            =&gt; <span class="dv">0</span>
}
<span class="kw">val</span> lst = <span class="fu">Cons</span>(<span class="dv">1</span>, <span class="fu">Cons</span>(<span class="dv">2</span>, <span class="fu">Cons</span>(<span class="dv">3</span>, Empty)))
<span class="kw">val</span> listRes: Int = <span class="fu">sumList</span>(lst)
<span class="fu">println</span>(listRes)  <span class="co">// 6</span></code></pre></div>
<h2 id="expressions">Expressions</h2>
<p>Finally, this is a definition of a tree aiming to represent mathematical expression:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C1NonDry.scala" snippet="ExprDef"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Expr</span>
<span class="kw">sealed</span> <span class="kw">trait</span> Expr
<span class="kw">case</span> <span class="kw">class</span>   <span class="fu">Add</span> (expr1  : Expr, expr2: Expr) <span class="kw">extends</span> Expr
<span class="kw">case</span> <span class="kw">class</span>   <span class="fu">Mult</span>(expr1  : Expr, expr2: Expr) <span class="kw">extends</span> Expr
<span class="kw">case</span> <span class="kw">class</span>   <span class="fu">Num</span> (literal: Int              ) <span class="kw">extends</span> Expr</code></pre></div>
<p>We have two node types for the summation and the multiplication, and one leaf type for the numbers.</p>
<p>Here is how an expression <code>2 * 3 + 3</code> looks like:</p>
<p><img src="/graphviz-images/42bfab5e927bbbd0f8c58953f70ffdac673ea13d.png" id="expr_diagram" /></p>
<p>How do we evaluate it? If it is a node representing a mathematical operation, first we need to evaluate its children and then do an operation represented by this node. If it is a leaf - a number - it just evaluates that number:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C1NonDry.scala" snippet="ExprEx"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Evaluate an expression</span>
<span class="kw">def</span> <span class="fu">eval</span>(e: Expr): Int = e <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Add</span> (x1, x2) =&gt; <span class="fu">eval</span>(x1) + <span class="fu">eval</span>(x2)
  <span class="kw">case</span> <span class="fu">Mult</span>(x1, x2) =&gt; <span class="fu">eval</span>(x1) * <span class="fu">eval</span>(x2)
  <span class="kw">case</span> <span class="fu">Num</span> (x)      =&gt; x
}
<span class="kw">val</span> expr = <span class="fu">Add</span>(<span class="fu">Mult</span>(<span class="fu">Num</span>(<span class="dv">2</span>), <span class="fu">Num</span>(<span class="dv">3</span>)), <span class="fu">Num</span>(<span class="dv">3</span>))
<span class="kw">val</span> exprRes: Int = <span class="fu">eval</span>(expr)
<span class="fu">println</span>(exprRes)  <span class="co">// 9</span></code></pre></div>
<h1 id="generalisation">Generalisation</h1>
<h2 id="structure-preserving-transformations">Structure preserving transformations</h2>
<p>Intuitively, every example above is similar. All of them involve a recursive structure that is collapsed from the &quot;bottom&quot; (the terminal element with no child substructures) to the &quot;top&quot; (the root structure). What is in common between the <code>natToInt</code>, <code>sumList</code> and <code>eval</code> functions? Can we abstract away these common elements, so that every one of these functions can be expressed in the same terms?</p>
<ul>
<li>Every example works on a recursive structure - a structure that has substructures of the same type as parts of itself.</li>
<li>They all involve recursive calls in order to transform these substructures. So, <code>natToInt</code> is called recursively on <code>previous</code> in order to evaluate <code>Succ(previous)</code>.</li>
<li>The results of these transformations are combined according to the parent structure.
<ul>
<li>In <code>sumList(Cons(head, tail))</code>, <code>head</code> is a part of the parent structure. <code>tail</code> is a substructure that is evaluated recursively via <code>sumList(tail)</code> and then combined with that <code>head</code> via addition.</li>
<li>In <code>eval</code> of either <code>Add</code> or <code>Mult</code>, we first need to call <code>eval</code> on the child expressions of these nodes, and then combine them depending on the parent structure - if it is <code>Add</code>, we do addition, if <code>Mult</code> - multiplication.</li>
</ul></li>
</ul>
<p>A better way to look at it is as if we were replacing the substructures by their evaluations and then evaluating the resulting structure.</p>
<p>For example, when evaluating a <code>Nat</code> depicted by <a href="#nat_diagram">the diagram above</a>, the next step of its evaluation would look as follows:</p>
<p><img src="/graphviz-images/5d792d630c018bdf91311640c94833a0741a61b7.png" /></p>
<p>Effectively, we have <code>Succ(previous = 2)</code>, which is then collapsed into <code>1 + 2</code> == <code>3</code>. However, <code>previous</code> is supposed to be a <code>Nat</code>, not an <code>Int</code>. In order to be able to write the above statement, we can allow the substructure to have an arbitrary type: <code>Succ[A](previous: A)</code>.</p>
<p>Similarly, the next step for the <code>IntList</code> <a href="#list_diagram">depicted</a> above will be:</p>
<p><img src="/graphviz-images/1b3c76cd35edd9772b5136a13fcd0e140d78c440.png" /></p>
<p>This is effectively a <code>Cons[Int](head = 1, tail = 5)</code> (again, notice how we introduce a type parameter for the substructure). After that, the <code>head</code> is added to the new <code>tail</code>, resulting in <code>6</code></p>
<p>Finally, for the <code>Expr</code> <a href="#expr_diagram">above</a>, the next step is to evaluate both of its two substructures:</p>
<p><img src="/graphviz-images/c5ccbcb94b2247e6938b3de7b0869d9ceaf1c14f.png" /></p>
<p>This is an <code>Add[Int](expr1 = 6, expr2 = 3)</code>, and the next step is to collapse it by doing <code>6 + 3</code>.</p>
<p>We are dealing with a <em>structure-preserving transformation</em> here. These kind of transformations are well understood in terms of <a href="https://en.wikipedia.org/wiki/Functor">functors</a>.</p>
<p>If we redefine our recursive structures such that they are parameterized by the type of their substructure, their types will have a form <code>F[A]</code> and we will be able to define functor instances for them.</p>
<p>Ordinarily, <code>A</code> in these <code>F[A]</code> is another <code>F[_]</code> (a substructure, reflecting the recursive nature of the parent structure) or <code>Nothing</code> (for terminal elements that do not have substructures). In our examples, we first do a <code>map</code>, turning <code>F[A]</code> into <code>F[B]</code>, where <code>B</code> is the type we are evaluating the structure into (in all our examples, <code>B</code> is <code>Int</code>). Next, given <code>F[B]</code>, we collapse it into a <code>B</code>. A function <code>F[B] =&gt; B</code> is called an <em>Algebra</em><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Now let us see how this theory can be applied in practice.</p>
<h2 id="new-definitions-for-the-recursive-structures">New definitions for the recursive structures</h2>
<p>In all our data structures, we need to specify the type of the substructures as a type parameter, so that we can then evaluate these substructures in a way that preserves the parent structure, via <code>map</code>.</p>
<p>The new definitions can go as follows:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C2Generalisation.scala" snippet="Defs"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Nat</span>
<span class="kw">sealed</span> <span class="kw">trait</span> Nat [+A]
<span class="kw">case</span> <span class="kw">class</span>   Succ[ A](previous: A) <span class="kw">extends</span> Nat[A      ]
<span class="kw">case</span> <span class="kw">object</span>  Zero                  <span class="kw">extends</span> Nat[Nothing]

<span class="co">// List</span>
<span class="kw">sealed</span> <span class="kw">trait</span> IntList[+A]
<span class="kw">case</span> <span class="kw">class</span>   Cons   [ A](head: Int, tail: A) <span class="kw">extends</span> IntList[A]
<span class="kw">case</span> <span class="kw">object</span>  Empty <span class="kw">extends</span> IntList[Nothing]

<span class="co">// Expr</span>
<span class="kw">sealed</span> <span class="kw">trait</span> Expr[+A]
<span class="kw">case</span> <span class="kw">class</span>   Add [ A](expr1  : A, expr2: A) <span class="kw">extends</span> Expr[A      ]
<span class="kw">case</span> <span class="kw">class</span>   Mult[ A](expr1  : A, expr2: A) <span class="kw">extends</span> Expr[A      ]
<span class="kw">case</span> <span class="kw">class</span>   <span class="fu">Num</span>     (literal: Int        ) <span class="kw">extends</span> Expr[Nothing]</code></pre></div>
<h2 id="functors">Functors</h2>
<p>If we want to use <code>map</code> on these data structures, they need functor instances. The definitions below are straightforward (do not forget to <code>import scalaz._, Scalaz._</code>, which is needed to bring functors in scope):</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C2Generalisation.scala" snippet="Functors"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Functors</span>
<span class="kw">implicit</span> <span class="kw">val</span> natFunct: Functor[Nat] = <span class="kw">new</span> Functor[Nat] {
  <span class="kw">def</span> map[A, B](fa: Nat[A])(f: A =&gt; B): Nat[B] = fa <span class="kw">match</span> {
    <span class="kw">case</span> <span class="fu">Succ</span>(x) =&gt; <span class="fu">Succ</span>(<span class="fu">f</span>(x))
    <span class="kw">case</span> Zero    =&gt; Zero
  }
}

<span class="kw">implicit</span> <span class="kw">val</span> intListFunct: Functor[IntList] = <span class="kw">new</span> Functor[IntList] {
  <span class="kw">def</span> map[A, B](fa: IntList[A])(f: A =&gt; B): IntList[B] = fa <span class="kw">match</span> {
    <span class="kw">case</span> <span class="fu">Cons</span>(head, tail) =&gt; <span class="fu">Cons</span>(head, <span class="fu">f</span>(tail))
    <span class="kw">case</span> Empty            =&gt; Empty
  }
}

<span class="kw">implicit</span> <span class="kw">val</span> exprFunct: Functor[Expr] = <span class="kw">new</span> Functor[Expr] {
  <span class="kw">def</span> map[A, B](fa: Expr[A])(f: A =&gt; B): Expr[B] = fa <span class="kw">match</span> {
    <span class="kw">case</span>     <span class="fu">Add</span> (x1, x2) =&gt; <span class="fu">Add</span> (<span class="fu">f</span>(x1), <span class="fu">f</span>(x2))
    <span class="kw">case</span>     <span class="fu">Mult</span>(x1, x2) =&gt; <span class="fu">Mult</span>(<span class="fu">f</span>(x1), <span class="fu">f</span>(x2))
    <span class="kw">case</span> x @ <span class="fu">Num</span> (_     ) =&gt; x
  }
}</code></pre></div>
<h2 id="catamorphism-first-attempt">Catamorphism: first attempt</h2>
<p>As discussed above, all we need to collapse a recursive structure is to map its substructures by the collapse function and then evaluate the resulting structure via an algebra. This recursion scheme is called a <em>catamorphism</em><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Let us try to define it:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C2Generalisation.scala" snippet="CataWrong"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Catamorphism draft</span>
<span class="co">// WARNING: DOES NOT COMPILE</span>
<span class="co">// def cata[F[_]: Functor, T, A](structure: F[T])(algebra: F[A] =&gt; A): A =</span>
<span class="co">//   algebra( structure.map(cata(_)(algebra)) )</span></code></pre></div>
<p>There is one problem with this code, however. In a recursive structure, <code>T</code> is supposed to be of the same type as <code>F[T]</code> by definition. Or else we will not be able to map it by <code>cata</code> as above, since <code>cata</code> will need a <code>Functor[T]</code>. In other words, <code>F[T] == T</code>. If so, we should also be able to write <code>structure: T</code> instead of <code>structure: F[T]</code> in the signature. Obviously, we can not have that in Scala, so what do we do?</p>
<h2 id="fixed-point-types">Fixed-point types</h2>
<h3 id="theory">Theory</h3>
<p>A <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)">fixed point</a> of a function <code>f(_)</code> is a value <code>x</code> such that <code>f(x) == x</code>. We can think of a higher-order function <code>fix</code> that computes a fixed point of its argument: <code>fix(f) == x</code> such that <code>f(x) == x</code>. By extension, <code>fix(f) == f(fix(f))</code> holds.</p>
<p>What if we bring the same ideas to the type theory? By analogy, a <em>fixed-point type</em> of a higher-kinded type <code>F[_]</code> is some type <code>T</code> such that <code>F[T] == T</code> - precisely what we need. We can also have a type <code>Fix[F[_]]</code>, such that <code>Fix[F] == F[Fix[F]]</code>.</p>
<p>Fixed-point types are interesting, because they can represent a recursive structure of any desired depth as a single type:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Fix[F] == F[Fix[F]] == F[F[Fix[F]]] == ...</code></pre></div>
<h3 id="practice">Practice</h3>
<p>I am not aware of a way you can define <code>Fix[F[_]]</code> so that the above equality holds - the compiler will think <code>F[T] != T</code> for any <code>F</code> and <code>T</code>, as far as I know.</p>
<p>It is possible to think of a workaround, though. In our <code>cata</code> definition above, we need to know that <code>F[T] == T</code> so that we can treat <code>T</code> as if it was <code>F[T]</code>. So in practice, we do not need to convince the compiler in that equality - a simple function <code>T =&gt; F[T]</code> is enough.</p>
<p>We can emulate the fixed-point type computation as in the theory above as follows:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C2Generalisation.scala" snippet="Fix"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Fixed point type</span>
<span class="kw">case</span> <span class="kw">class</span> Fix[F[_]](unfix: F[Fix[F]])</code></pre></div>
<p>So we just wrap an <code>F[_]</code> in this case class. <code>Fix[F] =&gt; F[Fix[F]]</code> can be defined as simply <code>fix =&gt; fix.unfix</code>.</p>
<h2 id="catamorphism-second-attempt">Catamorphism: second attempt</h2>
<p>Now we can define the catamorphism on a fixed-point type of a structure <code>F</code> as follows:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C2Generalisation.scala" snippet="CataRight"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Catamorphism</span>
<span class="kw">def</span> cata[F[_]: Functor, A](structure: Fix[F])(algebra: F[A] =&gt; A): A =
  <span class="fu">algebra</span>(structure.<span class="fu">unfix</span>.<span class="fu">map</span>(<span class="fu">cata</span>(_)(algebra)))</code></pre></div>
<h2 id="examples-using-cata">Examples using <code>cata</code></h2>
<p>Now we can use the new <code>cata</code> to define our examples:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C2Generalisation.scala" snippet="Examples"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Nat to Int</span>
<span class="kw">def</span> <span class="fu">natToInt</span>(n: Fix[Nat]): Int = cata[Nat, Int](n) {
  <span class="kw">case</span> <span class="fu">Succ</span>(x) =&gt; <span class="dv">1</span> + x
  <span class="kw">case</span> Zero    =&gt; <span class="dv">0</span>
}
<span class="kw">val</span> nat: Fix[Nat] =
  <span class="fu">Fix</span>(<span class="fu">Succ</span>(  <span class="co">// 3</span>
    <span class="fu">Fix</span>(<span class="fu">Succ</span>(  <span class="co">// 2</span>
      <span class="fu">Fix</span>(<span class="fu">Succ</span>(  <span class="co">// 1</span>
        Fix[Nat](Zero)  <span class="co">// 0</span>
      ))
    ))
  ))
<span class="kw">val</span> natRes = <span class="fu">natToInt</span>(nat)
<span class="fu">println</span>(natRes)  <span class="co">// 3</span>

<span class="co">// Sum a list of ints</span>
<span class="kw">def</span> <span class="fu">sumList</span>(l: Fix[IntList]): Int = cata[IntList, Int](l) {
  <span class="kw">case</span> <span class="fu">Cons</span>(head, tail) =&gt; head + tail
  <span class="kw">case</span> Empty            =&gt; <span class="dv">0</span>
}
<span class="kw">val</span> lst: Fix[IntList] =
  <span class="fu">Fix</span>(<span class="fu">Cons</span>(<span class="dv">1</span>,
    <span class="fu">Fix</span>(<span class="fu">Cons</span>(<span class="dv">2</span>,
      <span class="fu">Fix</span>(<span class="fu">Cons</span>(<span class="dv">3</span>,
        Fix[IntList](Empty)
      ))
    ))
  ))
<span class="kw">val</span> listRes = <span class="fu">sumList</span>(lst)
<span class="fu">println</span>(listRes)  <span class="co">// 6</span>

<span class="co">// Evaluate an expression</span>
<span class="kw">def</span> <span class="fu">eval</span>(e: Fix[Expr]): Int = cata[Expr, Int](e) {
  <span class="kw">case</span> <span class="fu">Add</span> (x1, x2) =&gt; x1 + x2
  <span class="kw">case</span> <span class="fu">Mult</span>(x1, x2) =&gt; x1 * x2
  <span class="kw">case</span> <span class="fu">Num</span> (x)      =&gt; x
}
<span class="kw">val</span> expr: Fix[Expr] =
  <span class="fu">Fix</span>(<span class="fu">Add</span>(
    <span class="fu">Fix</span>(<span class="fu">Mult</span>(
      Fix[Expr](<span class="fu">Num</span>(<span class="dv">2</span>)),
      Fix[Expr](<span class="fu">Num</span>(<span class="dv">3</span>))
    )),
    Fix[Expr](<span class="fu">Num</span>(<span class="dv">3</span>))
  ))
<span class="kw">val</span> exprRes = <span class="fu">eval</span>(expr)
<span class="fu">println</span>(exprRes)  <span class="co">// 9</span></code></pre></div>
<p>First thing that catches the eye, probably, is how we need to embed every layer of the recursive structures into <code>Fix</code>. This is cumbersome, but fine as for the proof of concept.</p>
<p>Notice how all of the examples are now expressed in terms of one function - <code>cata</code>. We have successfully abstracted the common parts of the recursive structure collapse task.</p>
<p>Also, notice how we have gotten rid of the recursive calls in all of our examples. The recursion is now abstracted away in <code>cata</code>, so that the user does not need to deal with it directly.</p>
<h1 id="matryoshka">Matryoshka</h1>
<p>Catamorphisms are not the only recursion scheme out there. Many more exist. And, of course, you do not need to implement them from scratch. <a href="https://github.com/slamdata/matryoshka">Matryoshka</a> is a library that specializes on implementing recursion schemes on fixed-point types of recursive structures.</p>
<h2 id="recursion-scheme-mechanics">Recursion scheme mechanics</h2>
<p><a href="/plantuml-images/bbb3113f7af1c9c47e4fbe8bf908944c5728eb4d.svg"><img src="/plantuml-images/bbb3113f7af1c9c47e4fbe8bf908944c5728eb4d.svg" style="width:100.0%" /></a></p>
<p>The library is centered around the notion of the fixed-point types. In the diagram above, the core type classes are marked with blue &quot;T&quot;, and their companion objects - with green &quot;O&quot;. These type classes describe what it means for an arbitrary type <code>T</code> to be a fixed-point type.</p>
<p>The <code>Based[T]</code> type class captures the idea that a type <code>T</code> must &quot;know&quot; the type <code>Base[_]</code>, for which (supposedly) <code>Base[T] == T</code>. Supposedly, since there's nothing in <code>Based</code> whatsoever to suggest that equality.</p>
<h3 id="recursive---to-tear-structures-down">Recursive - to tear structures down</h3>
<p><code>Recursive[T]</code> has a single abstract method, <code>project</code>, and a whole lot of methods specifying various schemes of recursion you can run on <code>T</code>. Our <code>cata</code> is among them. But obviously <code>project</code> is of the most interest, since it is the only abstract method and hence its implementation sheds light on what it means for a type <code>T</code> to be <code>Recursive</code>.</p>
<p><code>project</code> can be interpreted as <code>T =&gt; Base[T]</code>. In the section on <a href="#practice">practical applications</a> of the fixed-point type we already discussed that it is crucial to be able to extract the type <code>F[T]</code> from its fixed point representation <code>T</code>. If <code>T</code> is <code>Recursive</code> you can extract <code>F[T]</code> from <code>T</code>, where <code>F</code> is the higher-kinded type <code>T</code> is a fixed point of. You can specify this <code>F</code> via a type in the companion object of <code>Recursive</code> - <code>Recursive.Aux[T, F[_]]</code>.</p>
<p>The fact that you can extract <code>F[T]</code> from <code>T</code> is a necessary condition for the recursion schemes defined in the <code>Recursive[T]</code> type class. They have one thing in common: they all tear down a recursive structure. Here is an intuition for this:</p>
<p><img src="/graphviz-images/93e3ddef86449a067a22036d49c7afd353d1d2a7.png" /></p>
<p><code>project</code> is a &quot;taker&quot; - it is capable of <em>extracting</em> information from <code>T</code>. Naturally, if you take <em>something</em> from <code>T</code>, there becomes less of that <em>something</em> in <code>T</code>. This way, you can &quot;pump&quot; the structure, layer by layer, from <code>T</code>, and do whatever you want with it, until there is nothing left in <code>T</code>.</p>
<p>The arrow on the diagram points from <code>F[T]</code> towards <code>T</code> to indicate that <code>T</code> is a member of the structure <code>F[T]</code>. It does not indicate a direction of the information flow (&quot;who takes from whom&quot;) in the <code>project</code> application.</p>
<h3 id="corecursive---to-build-structures-up">Corecursive - to build structures up</h3>
<p>It follows from the name that <code>Corecursive</code> is a dual of <code>Recursive</code> - hence, it must do the opposite thing to what <code>Recursive</code> does.</p>
<p>Indeed, it mirrors <code>Recursive</code> in a sense that it also has a single abstract method and a bunch of recursion schemes based on it. This method is <code>embed</code> and is roughly <code>Base[T] =&gt; T</code>. If <code>project</code> takes the information out of the structure and hence is good for evaluating them via algebras, <code>embed</code> places the information into the structure, hence building it up:</p>
<p><img src="/graphviz-images/dae7a1d0c8672f7a3563c78e90ba6653f7ca658d.png" /></p>
<p>An example of a recursion scheme that takes an advantage of such a capability is <em>anamorphism</em> <code>ana: (A, Coalgebra[Base, A]) =&gt; T</code>. <code>Coalgebra</code>, being a dual of <code>Algebra</code>, is <code>A =&gt; Base[A]</code> and describes how to build up a single layer of the structure from <code>A</code>. <code>ana</code> aims to build deep structures using an initial element <code>A</code> and a way to build a single layer from it. But this is a bit out of scope of the article, since we were focusing on catamorphisms.</p>
<h2 id="examples-revisited">Examples revisited</h2>
<p>Let us now see how to rewrite our examples from the previous chapters using Matryoshka.</p>
<p>First of all, <em>make sure you apply <a href="https://github.com/milessabin/si2712fix-plugin">SI-2712 fix</a></em>, or else implicits won't resolve correctly and this will spoil you all the fun.</p>
<p>Next, do some Matryoshka imports:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> matryoshka.{ Recursive, Corecursive }
<span class="kw">import</span> matryoshka.<span class="fu">data</span>.<span class="fu">Fix</span>  <span class="co">// The fixed-point type similar to the one we implemented ad-hoc, but with Recursive and Corecursive instances.</span>
<span class="kw">import</span> matryoshka.<span class="fu">implicits</span>.<span class="fu">_</span>  <span class="co">// Syntax</span></code></pre></div>
<p>And here is the code for the examples:</p>
<div class="sourceCode" include="code/matryoshka-intro/src/main/scala/matryoshkaintro/C3Matryoshka.scala" snippet="Examples"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Nat to Int</span>
<span class="kw">def</span> natToInt[T](n: T)(<span class="kw">implicit</span> T: Recursive.<span class="fu">Aux</span>[T, Nat]): Int = n.<span class="fu">cata</span>[Int] {
  <span class="kw">case</span> <span class="fu">Succ</span>(x) =&gt; <span class="dv">1</span> + x
  <span class="kw">case</span> Zero    =&gt; <span class="dv">0</span>
}
<span class="kw">def</span> nat[T](<span class="kw">implicit</span> T: Corecursive.<span class="fu">Aux</span>[T, Nat]): T =
  <span class="fu">Succ</span>(
    <span class="fu">Succ</span>(
      <span class="fu">Succ</span>(
        Zero.<span class="fu">embed</span>
      ).<span class="fu">embed</span>
    ).<span class="fu">embed</span>
  ).<span class="fu">embed</span>
<span class="kw">val</span> natRes = <span class="fu">natToInt</span>(nat[Fix[Nat]])
<span class="fu">println</span>(natRes)  <span class="co">// 3</span>

<span class="co">// Sum a list of ints</span>
<span class="kw">def</span> sumList[T](l: T)(<span class="kw">implicit</span> T: Recursive.<span class="fu">Aux</span>[T, IntList]): Int = l.<span class="fu">cata</span>[Int] {
  <span class="kw">case</span> <span class="fu">Cons</span>(head, tail) =&gt; head + tail
  <span class="kw">case</span> Empty            =&gt; <span class="dv">0</span>
}
<span class="kw">def</span> lst[T](<span class="kw">implicit</span> T: Corecursive.<span class="fu">Aux</span>[T, IntList]): T =
  <span class="fu">Cons</span>(<span class="dv">1</span>,
    <span class="fu">Cons</span>(<span class="dv">2</span>,
      <span class="fu">Cons</span>(<span class="dv">3</span>,
        Empty.<span class="fu">embed</span>
      ).<span class="fu">embed</span>
    ).<span class="fu">embed</span>
  ).<span class="fu">embed</span>
<span class="kw">val</span> listRes = <span class="fu">sumList</span>(lst[Fix[IntList]])
<span class="fu">println</span>(listRes)  <span class="co">// 6</span>

<span class="co">// Evaluate an expression</span>
<span class="kw">def</span> eval[T](e: T)(<span class="kw">implicit</span> T: Recursive.<span class="fu">Aux</span>[T, Expr]): Int = e.<span class="fu">cata</span>[Int] {
  <span class="kw">case</span> <span class="fu">Add</span> (x1, x2) =&gt; x1 + x2
  <span class="kw">case</span> <span class="fu">Mult</span>(x1, x2) =&gt; x1 * x2
  <span class="kw">case</span> <span class="fu">Num</span> (x)      =&gt; x
}
<span class="kw">def</span> expr[T](<span class="kw">implicit</span> T: Corecursive.<span class="fu">Aux</span>[T, Expr]): T =
  <span class="fu">Add</span>(
    <span class="fu">Mult</span>(
      <span class="fu">Num</span>(<span class="dv">2</span>).<span class="fu">embed</span>,
      <span class="fu">Num</span>(<span class="dv">3</span>).<span class="fu">embed</span>
    ).<span class="fu">embed</span>,
    <span class="fu">Num</span>(<span class="dv">3</span>).<span class="fu">embed</span>
  ).<span class="fu">embed</span>
<span class="kw">val</span> exprRes = <span class="fu">eval</span>(expr[Fix[Expr]])
<span class="fu">println</span>(exprRes)  <span class="co">// 9</span></code></pre></div>
<p>Main differences from our <a href="#examples-using-cata">ad-hoc solution</a>:</p>
<ul>
<li>Fixed point behavior generalized: we no longer use a concrete type <code>Fix</code> to either build up or tear down our structures. Instead, we require corresponding behavior via <code>Recursive</code> and <code>Corecursive</code> type classes.</li>
<li>Nicer syntax for <code>cata</code>: only one type parameter and the convenient OOP-like syntax with the <code>.</code> - thanks to <code>import matryoshka.implicits._</code>.</li>
<li>Nicer syntax for building up the structures - previously we had to wrap every layer explicitly in <code>Fix</code>, now we have an <code>embed</code> method for it. Less parentheses.</li>
</ul>
<h1 id="conclusion">Conclusion</h1>
<p>Whenever you use recursion in your code, chances are that what you do is already abstracted in one of the recursion schemes. The benefit from using them instead of bare recursion is similar to the benefit when using <code>for</code> or <code>while</code> instead of <code>goto</code> - more concise, readable and secure code.</p>
<p>Matryoshka is an framework that does a great job introducing someone to these concepts. It has one rather significant drawback, however - at the moment, it is not stack-safe. For larger structures, this becomes a problem.</p>
<p>Nevertheless, in my opinion, every programmer aspiring to perfect their craft would benefit greatly from trying to solve their everyday recursive tasks in a more &quot;literate&quot; way Matryoshka offers.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://twitter.com/headinthebox/status/384105824315928577?lang=en" class="uri">https://twitter.com/headinthebox/status/384105824315928577?lang=en</a><a href="#fnref1">â†©</a></p></li>
<li id="fn2"><p><a href="https://github.com/slamdata/matryoshka/blob/8dbabe9a9c21158abdb1d4d5ff2fe7a1f416f1d6/core/shared/src/main/scala/matryoshka/package.scala#L53">Matryoshka definition</a><a href="#fnref2">â†©</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/F-algebra" class="uri">https://en.wikipedia.org/wiki/F-algebra</a><a href="#fnref3">â†©</a></p></li>
<li id="fn4"><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125" class="uri">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125</a><a href="#fnref4">â†©</a></p></li>
</ol>
</div>
</div>
</div>


      <div class="footer">
        <div class="disclaimer">
  <p>
    Â© Anatolii Kmetiuk, 2016 - 2020 &mdash; built using <a href="https://github.com/swanson/lagom">Lagom theme</a>. Powered by <a href="https://github.com/anatoliykmetyuk/thera">Thera</a>. The sources of this site are availabel on <a href="https://github.com/anatoliykmetyuk/anatoliykmetyuk.github.io">GitHub</a>.
  </p>
</div>
      </div>
    </div>
  </div>
</body>
</html>
