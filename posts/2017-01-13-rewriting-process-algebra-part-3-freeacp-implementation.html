<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Anatolii Kmetiuk - Rewriting Process Algebra, Part 3: FreeACP Implementation</title>
<meta name="author" content="Anatolii Kmetiuk" />

<meta name="description" content="A rewriting-based process algebra implementation in Scala.">
<meta name="keywords" content="process algebra,scala,subscript,free object,functional programming,algebra of communicating processes,acp,category theory,concurrent programming,concurrency,reactive programming">

<!-- Facebook tags -->
<meta property="og:title" content="Rewriting Process Algebra, Part 3: FreeACP Implementation">
<meta property="og:type" content="article">
<meta property="og:url" content="http://akmetiuk.com/posts/2017-01-13-rewriting-process-algebra-part-3-freeacp-implementation.html">
<meta property="og:image" content="http://akmetiuk.com/assets/imgs/avatar_100.png">
<meta property="og:description" content="A rewriting-based process algebra implementation in Scala.">
<meta property="og:site_name" content="The blog of Anatolii Kmetiuk">
<meta property="og:locale" content="en-GB">

<!-- Twitter tags -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:description" content="A rewriting-based process algebra implementation in Scala." />
<meta name="twitter:title" content="Rewriting Process Algebra, Part 3: FreeACP Implementation" />
<meta name="twitter:site" content="@AKmetyuk" />
<meta name="twitter:image" content="http://akmetiuk.com/assets/imgs/avatar_100.png" />
<meta name="twitter:creator" content="@AKmetyuk" />


  <link rel="canonical" href="http://akmetiuk.com/posts/2017-01-13-rewriting-process-algebra-part-3-freeacp-implementation.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="../favicon.png">
  <link rel="alternate" type="application/atom+xml" title="Anatolii Kmetiuk" href="http://akmetiuk.com/atom.xml" />

  <link rel="stylesheet" href="../assets/all.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha256-k2/8zcNbxVIh5mnQ52A0r3a6jAgMGxFJFE2707UxGCk= sha512-ZV9KawG2Legkwp3nAlxLIVFudTauWuBpC10uEafMHYL0Sarrz5A7G79kXh5+5+woxQ5HM559XX2UZjMJ36Wplg==" crossorigin="anonymous">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <h1>Hi.</h1>
  <a href="../">
    <img src="../assets/imgs/avatar_200.png" id="logo" alt="Blog logo" />
  </a>
  <h2>I'm <a href="../">Anatolii Kmetiuk</a>.</h2>
  <div id="bio">
    <p>Scala consultant. I am interested in Category Theory, Type-level programming and Deep Learning. I occasionally write here about what I do.</p>
    <p>If you are interested in my services, you can contact me via the following e-mail: anatoliykmetyuk at gmail dot com.</p>
  </div>
  <div id="social">
    Follow me:
<div id="stalker">
  
  <a title="anatoliykmetyuk on Github" href="https://github.com/anatoliykmetyuk">
    <i class="fa fa-github-square"></i>
  </a>
  

  
  <a title="AKmetyuk on Twitter" href="https://twitter.com/AKmetyuk">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  
  <a title="Anatolii Kmetiuk on LinkedIn" href="https://www.linkedin.com/in/anatoliykmetyuk">
    <i class="fa fa-linkedin-square"></i>
  </a>
  


  
  <a title="Atom feed" id="atom" href="../atom.xml">
    <i class="fa fa-rss-square"></i>
  </a>
  
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  January 13, 2017
  <a href="../">
    <i class="home fa fa-home"></i>
  </a>
</p>

<h1 class="title">Rewriting Process Algebra, Part 3: FreeACP Implementation</h1>

<div id="post">
  <ul>
<li><a href="#tree">Tree</a></li>
<li><a href="#axioms">Axioms</a></li>
<li><a href="#execution">Execution</a></li>
<li><a href="#suspension-type-as-a-free-object">Suspension type as a free object</a><ul>
<li><a href="#languaget-as-a-free-s"><code>LanguageT</code> as a free <code>S</code></a></li>
<li><a href="#compilers-for-languaget">Compilers for <code>LanguageT</code></a><ul>
<li><a href="#default-compiler">Default compiler</a></li>
<li><a href="#compiler-framework">Compiler framework</a></li>
</ul></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<p>This is the third part of my progress report on a rewriting-based implementation of <a href="https://github.com/scala-subscript/subscript">SubScript</a>, <a href="https://github.com/anatoliykmetyuk/free-acp">FreeACP</a>. This part covers the architecture of FreeACP I came up with so far while implementing the rewriting engine for SubScript.</p>
<p>If you have not read the previous parts of this report, you are advised to do so before reading this one:</p>
<ul>
<li><a href="../blog/2017/01/11/rewriting-process-algebra-part-1-introduction-to-process-algebra.html">Rewriting Process Algebra, Part 1: Introduction to Process Algebra</a></li>
<li><a href="../blog/2017/01/12/rewriting-process-algebra-part-2-engine-theory.html">Rewriting Process Algebra, Part 2: Engine Theory</a></li>
</ul>
<h1 id="tree">Tree</h1>
<p>Process algebra expressions are modeled as ordinary <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L6">Tree</a>s. A <code>Tree</code> has a higher-kinded type argument to it, <code>S[_]</code>. <code>S</code> is the boxed type of a suspended computation’s result, for example <code>Future[_]</code>.</p>
<p>There are the following notorious subclasses of <code>Tree</code>:</p>
<ul>
<li>Operators: <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L85">Sequence</a> and <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L86">Choice</a>.</li>
<li>Terminal cases: <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L88">Result</a> and its subclasses: <code>Success</code> and <code>Failure</code>, representing <code>ε</code> and <code>δ</code> respectively.</li>
<li><a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L83">Suspend</a> - carries a suspended computation.</li>
</ul>
<p>A suspended computation is carried by <code>Suspend</code> nodes as <code>S[Tree[S]]</code> and should be interpreted as follows: There is some computation running under <code>S</code> and the result of this computation is another process algebra expression <code>Tree[S]</code>.</p>
<p>For example, an ordinary AA’s evaluation can be represented as <code>S[Result[S]]</code> and should be read as follows: There is some action running under <code>S</code>, and if it is successful (no exception happens), the result is <code>ε</code>, otherwise <code>δ</code>.</p>
<h1 id="axioms">Axioms</h1>
<p>Sets of <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L12">rewriting</a> and <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L44">suspension</a> axioms are defined as partial functions and are straightforward to read.</p>
<p>Some points to note about them:</p>
<ul>
<li>Rewriting axioms take a <code>Tree[S]</code> and return a <code>Tree[S]</code> as a result - they just rewrite a given tree.</li>
<li>Suspension axioms take a <code>Tree[S]</code> and return a <code>List[S[Tree[S]]]</code>. <code>List</code> reflects that there may be a need to make a choice between several trees. <code>S[Tree[S]]</code> means that the trees which the current one should be rewritten to are not readily available and are computed in <code>S</code>.</li>
</ul>
<h1 id="execution">Execution</h1>
<p>These axioms are applied in a <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L67">loop</a> until a terminal case is reached, as described in the theory in <a href="../blog/2017/01/12/rewriting-process-algebra-part-2-engine-theory.html">Part 2</a>.</p>
<h1 id="suspension-type-as-a-free-object">Suspension type as a free object</h1>
<p>If one has a <code>Tree[S]</code>, they do not have much choice but to execute it under <code>S</code>. This may not always be desirable: For instance, one may have a <code>Tree[</code><a href="https://static.javadoc.io/org.typelevel/cats-core_2.12/0.8.1/cats/Eval$.html">Eval</a><code>]</code>, but want to execute it in parallel via <code>Future</code>.</p>
<p>Alternatively, <code>S</code> may stay constant, but the way of execution under <code>S</code> may not. A good example of this is the <code>setText(textField, string)</code> AA from our GUI example: We agreed that it sets the text of <code>textField</code> to <code>string</code> under a particular GUI framework we are working under. But what if we want our program to work under several GUI frameworks? Each of them will have its own implementation of <code>textField</code> and the way to set its text will differ between the frameworks.</p>
<p>For this reason, the function that runs the trees, <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Tree.scala#L65">runM</a>, can take a natural transformation, <code>S ~&gt; G</code>, using which one can specify how to map a suspended computation <code>S</code> to a suspended computation <code>G</code>.</p>
<p>Further increasing flexibility, we may even have a default implementation of <code>S</code> as a <a href="https://en.wikipedia.org/wiki/Free_object">free object</a>, in style of the <a href="http://typelevel.org/cats/datatypes/freemonad.html">free monad</a>.</p>
<h2 id="languaget-as-a-free-s"><code>LanguageT</code> as a free <code>S</code></h2>
<p>The pattern is as follows: All the expressions for FreeACP are written with suspension type <code>S</code> equal to <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Language.scala#L5">LanguageT</a> by default. These expressions are of type <code>Tree[LanguageT]</code>.</p>
<p><code>LanguageT</code> is a free object - it does not do anything by itself, but remembers the operations you tried to perform on it. It does this by <a href="https://en.wikipedia.org/wiki/Reification_(computer_science)">reifying</a> all the operations done on it into case classes. For example, <code>t.map(f) == MapLanguage(t, f)</code>.</p>
<p>Next, the user can select whichever <code>S</code> they want to execute their program under, define a natural transformation <code>LanguageT ~&gt; S</code> (roughly, <code>LanguageT[Tree[LanguageT]] =&gt; S[Tree[LanguageT]]</code>) and use it in the <code>runM</code> method to execute the <code>LanguageT</code> instances. This natural transformation is called the <strong>compiler</strong>, it compiles your program written under <code>LanguageT</code> to a concrete suspension type <code>S</code>.</p>
<p>In our example of the <code>setText</code> AA, one may define the following class to represent its action:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> SetText[TF](textField: TF, string: String) <span class="kw">extends</span> LanguageT[Result[LanguageT]]</code></pre></div>
<p>It contains all the data necessary to set the text of the text field, but does not say anything about <em>how</em> to do it. Then, one can define a different natural transformation <code>LanguageT ~&gt; S</code> for each GUI framework they are working under, each specifying the way this particular framework performs this action. This way, a GUI controller can be written once and executed on many GUI frameworks.</p>
<p>For example, such a natural transformation under Swing may look like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> (LanguageT ~&gt; Future) {
  <span class="kw">override</span> <span class="kw">def</span> apply[A](t: LanguageT[A]): Future[A] =
    t <span class="kw">match</span> {
      <span class="kw">case</span> SetText[TextField](textField, string) =&gt;
        Future {
          Swing.<span class="fu">onEDTWait</span> { textField.<span class="fu">text</span> = string }
          ε
        }
    }
}</code></pre></div>
<p>The point to notice here is that all the things specific to the GUI framework are encapsulated in this compiler, and hence one program can be executed under many GUI frameworks, provided one has proper compilers for these frameworks.</p>
<h2 id="compilers-for-languaget">Compilers for <code>LanguageT</code></h2>
<h3 id="default-compiler">Default compiler</h3>
<p>There is a number of default subclasses of <code>LanguageT</code> that reify operations that are used in the suspension axioms (recall that the suspension axioms rely on <code>map: (A =&gt; B) =&gt; (S[A] =&gt; S[B])</code> and <code>suspend: A =&gt; S[A]</code>) and hence are necessary for the <code>LanguageT</code> to be used as a suspension type.</p>
<p>Hence, there is also a <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Language.scala#L38">default compiler</a> for such subclasses.</p>
<p>Internally, the compiler is a partial function, specifying how to translate various subclasses of <code>LanguageT</code> to <code>F</code>. For example, <code>case MapLanguage(t1, f)   =&gt; F.map(mainCompiler(t1))(f)</code> is the line handling <code>MapLanguage</code>, a reification of the <code>map</code> method called on <code>LanguageT</code>. All it does is mapping <code>t1</code> by <code>f</code> using a <code>F.map</code> where variable <code>F</code> is of type <code>Functor[F]</code>. In essence, the compiler describes how to <em>delegate</em> the <code>map</code> to the functor of <code>F</code>, whatever this <code>F</code> is.</p>
<p>In its definition, the default compiler declares some implicit arguments: <code>implicit F: Functor[F], S: Suspended[F]</code>. This means that internally it delegates some operations to a <code>Functor</code> and a <code>Suspend</code> type classes and hence depends on them. So if they are not in scope, there’s nothing to delegate to and hence one can’t instantiate the compiler for <code>F</code>. This also works another way around: whatever your <code>F</code>, if you have a <code>Suspended</code> and a <code>Functor</code> for it, you will be able to compile your program under that <code>F</code>.</p>
<p><em>One can get the default compiler for <code>F</code> if and only if one has <code>Functor[F]</code> and <code>Suspended[F]</code>.</em></p>
<h3 id="compiler-framework">Compiler framework</h3>
<p>It is possible to compose compilers for different subclasses of <code>LanguageT</code>. One can define their own subclass of <code>LanguageT</code> and add a compiler for that subclass, this way extending the expressive power they have.</p>
<p>By default, one can only use an <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Language.scala#L15">atomic action</a> to create a suspended computation, but one can define more primitives to write process algebra expressions with, as in the <code>setText()</code> example above.</p>
<p>The simplest example is a <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/component/Say.scala#L9">say</a> primitive that just prints something to the console. The pattern for <code>say</code> is as follows: first, we define a <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/component/Say.scala#L8">subclass</a> of <code>LanguageT</code> - wherever we use it, we want it to mean “print the payload to the console”. Next, we define a <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/component/Say.scala#L11">compiler</a> capable of executing that subclass under some <code>F</code>. This compiler has a very similar structure to the default one, except that it can only handle <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/component/Say.scala#L13">one case</a> of the language: <code>SayContainer</code>.</p>
<p>Once defined, all the compilers can be composed to form a single compiler to be used in <code>runM</code>. This is done via the <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Language.scala#L34">compiler</a> function. Since all the “small” compilers return an <code>Option[F[Tree[LanguageT]]]</code>, the “large” compiler iterates through the list of the “small” ones until a <code>Some(_)</code> is returned.</p>
<p>Also, the “small” compilers, or <a href="https://github.com/anatoliykmetyuk/free-acp/blob/0932ccde36b0efa83dd01b25ca1fee393154d987/core/src/main/scala/freeacp/Language.scala#L32">PartialCompiler</a>s are of type <code>Compiler[F] =&gt; LanguageT ~&gt; OptionK[F, ?]</code> (<code>Compiler[F]</code> is <code>LanguageT ~&gt; F</code>, and <code>OptionK[F[_], A]</code> is <code>Option[F[A]]</code>). This means that we are able to use the “large” compiler from the “small” ones, so that we can invoke it recursively.</p>
<h1 id="conclusion">Conclusion</h1>
<p>FreeACP is still a work in progress. The theory and architecture are far from perfect and hopefully will endure substantial changes in future. However, the expressive power it grants is promising and worth exploring.</p>
</div>

<!-- 
<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
     {% for post in site.related_posts limit:3 %}
    <li>
      <span>{{ post.date | date_to_string }} &raquo;</span> <a href="{{ post.url }}">{{ post.title }}</a>
    </li>
    {% endfor %}
  </ul>
</div>
 -->
<div id="spread">
  <!-- Twitter -->
  <a class="twitter-share-button" href="https://twitter.com/intent/tweet?text=Rewriting Process Algebra, Part 3: FreeACP Implementation" data-size="large"><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  Tweet</a>
  <a href="https://twitter.com/AKmetyuk" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @AKmetyuk</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = 'http://akmetiuk.com/posts/2017-01-13-rewriting-process-algebra-part-3-freeacp-implementation.html';
this.page.identifier = '/posts/2017-01-13-rewriting-process-algebra-part-3-freeacp-implementation.html';
};

(function() {
var d = document, s = d.createElement('script');

s.src = '//anatoliikmetiukblog.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


      <div class="footer">
        <div class="disclaimer">
  <p>
    © Anatolii Kmetiuk, 2016 &mdash; built using <a href="https://github.com/swanson/lagom">Lagom theme</a>. Powered by <a href="https://jaspervdj.be/hakyll/">Hakyll</a>. The sources of this site are availabel on <a href="https://github.com/anatoliykmetyuk/anatoliykmetyuk.github.io">GitHub</a>.
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-75795865-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
